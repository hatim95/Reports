/**
 * Represents a Work-Report (R) generated by a guarantor.
 * This is the primary output of the off-chain refinement process.
 */

import { validateRequired, validateType, validateInstanceOf } from '../utils/validator.ts';
import { WorkPackage } from './WorkPackage.ts';
import { RefinementContext } from './RefinementContext.ts';
import { AvailabilitySpec } from './AvailabilitySpec.ts';

export class WorkReport {
    workPackage: WorkPackage;
    refinementContext: RefinementContext;
    pvmOutput: string;
    gasUsed: number;
    availabilitySpec: AvailabilitySpec | null;
    guarantorSignature: string;
    guarantorPublicKey: string;
    coreIndex: number;
    slot: number;
    dependencies: string[];

    constructor(
        workPackage: WorkPackage,
        refinementContext: RefinementContext,
        pvmOutput: string,
        gasUsed: number,
        availabilitySpec: AvailabilitySpec | null,
        guarantorSignature: string,
        guarantorPublicKey: string,
        coreIndex: number,
        slot: number,
        dependencies: string[] = []
    ) {
        validateInstanceOf(workPackage, 'Work Package', WorkPackage);
        validateInstanceOf(refinementContext, 'Refinement Context', RefinementContext);
        validateRequired(pvmOutput, 'PVM Output');
        validateType(pvmOutput, 'PVM Output', 'string');
        validateRequired(gasUsed, 'Gas Used');
        validateType(gasUsed, 'Gas Used', 'number');
        if (gasUsed < 0) throw new Error('Gas Used cannot be negative.');

        if (availabilitySpec !== null) {
            validateInstanceOf(availabilitySpec, 'Availability Specification', AvailabilitySpec);
            validateType(guarantorSignature, 'Guarantor Signature', 'string');
            validateRequired(guarantorPublicKey, 'Guarantor Public Key');
            validateType(guarantorPublicKey, 'Guarantor Public Key', 'string');
        }

        validateRequired(coreIndex, 'Core Index');
        validateType(coreIndex, 'Core Index', 'number');
        if (coreIndex < 0) throw new Error('Core Index cannot be negative.');

        validateRequired(slot, 'Slot');
        validateType(slot, 'Slot', 'number');
        if (slot < 0) throw new Error('Slot cannot be negative.');

        if (!Array.isArray(dependencies) || !dependencies.every(d => typeof d === 'string')) {
            throw new Error('Dependencies must be an array of strings.');
        }

        this.workPackage = workPackage;
        this.refinementContext = refinementContext;
        this.pvmOutput = pvmOutput;
        this.gasUsed = gasUsed;
        this.availabilitySpec = availabilitySpec;
        this.guarantorSignature = guarantorSignature;
        this.guarantorPublicKey = guarantorPublicKey;
        this.coreIndex = coreIndex;
        this.slot = slot;
        this.dependencies = dependencies;
    }

    /**
     * Converts the WorkReport to a plain object for serialization (excluding signature for hashing).
     */
    toSignableObject(): Record<string, unknown> {
        return {
            workPackage: this.workPackage.toObject(),
            refinementContext: this.refinementContext.toObject(),
            pvmOutput: this.pvmOutput,
            gasUsed: this.gasUsed,
            availabilitySpec: this.availabilitySpec ? this.availabilitySpec.toObject() : null,
            coreIndex: this.coreIndex,
            slot: this.slot,
            dependencies: this.dependencies,
        };
    }

    /**
     * Converts the WorkReport to a plain object for full serialization (including signature).
     */
    toObject(): Record<string, unknown> {
        return {
            ...this.toSignableObject(),
            guarantorSignature: this.guarantorSignature,
            guarantorPublicKey: this.guarantorPublicKey,
        };
    }
}
