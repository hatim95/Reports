/**
 * Represents a Work-Report (R) generated by a guarantor.
 * This is the primary output of the off-chain refinement process.
 */
// Re-using WorkReport from Phase 1
import { validateRequired, validateType, validateInstanceOf } from '../utils/validator.js';
import { WorkPackage } from './WorkPackage.js';
import { RefinementContext } from './RefinementContext.js';
import { AvailabilitySpec } from './AvailabilitySpec.js';

export class WorkReport {
    /**
     * @param {WorkPackage} workPackage - The Work-Package (P) being reported on.
     * @param {RefinementContext} refinementContext - The context (C) used for refinement.
     * @param {string} pvmOutput - The output of the V_R PVM execution.
     * @param {number} gasUsed - The gas consumed by the V_R PVM execution.
     * @param {AvailabilitySpec} availabilitySpec - The availability specification (Y) for the report.
     * @param {string} guarantorSignature - The signature of the guarantor on the report (base64).
     * @param {string} guarantorPublicKey - The public key of the guarantor (base64).
     * @param {number} coreIndex - The index of the core this report is for.
     * @param {number} slot - The slot number at which the report was generated/submitted.
     * @param {string[]} dependencies - List of WorkDigest hashes this report depends on.
     */
    constructor(workPackage, refinementContext, pvmOutput, gasUsed, availabilitySpec, guarantorSignature, guarantorPublicKey, coreIndex, slot, dependencies = []) {
        validateInstanceOf(workPackage, 'Work Package', WorkPackage);
        validateInstanceOf(refinementContext, 'Refinement Context', RefinementContext);
        validateRequired(pvmOutput, 'PVM Output');
        validateType(pvmOutput, 'PVM Output', 'string');
        validateRequired(gasUsed, 'Gas Used');
        validateType(gasUsed, 'Gas Used', 'number');
        if (gasUsed < 0) throw new Error('Gas Used cannot be negative.');
        // Allow availabilitySpec to be null for preliminary report (for encoding)
        // Only require signature/publicKey if availabilitySpec is not null AND signature is not empty
        if (availabilitySpec !== null) {
            validateInstanceOf(availabilitySpec, 'Availability Specification', AvailabilitySpec);
            validateType(guarantorSignature, 'Guarantor Signature', 'string');
            // Only require non-empty signature if not in pre-signing phase
            // (i.e., allow empty string for signature during signing step)
            // You may want to enforce non-empty signature elsewhere after signing
            validateRequired(guarantorPublicKey, 'Guarantor Public Key');
            validateType(guarantorPublicKey, 'Guarantor Public Key', 'string');
        }
        validateRequired(coreIndex, 'Core Index');
        validateType(coreIndex, 'Core Index', 'number');
        if (coreIndex < 0) throw new Error('Core Index cannot be negative.');
        validateRequired(slot, 'Slot');
        validateType(slot, 'Slot', 'number');
        if (slot < 0) throw new Error('Slot cannot be negative.');
        if (!Array.isArray(dependencies) || !dependencies.every(d => typeof d === 'string')) {
            throw new Error('Dependencies must be an array of strings.');
        }

        this.workPackage = workPackage;
        this.refinementContext = refinementContext;
        this.pvmOutput = pvmOutput;
        this.gasUsed = gasUsed;
        this.availabilitySpec = availabilitySpec;
        this.guarantorSignature = guarantorSignature;
        this.guarantorPublicKey = guarantorPublicKey;
        this.coreIndex = coreIndex;
        this.slot = slot;
        this.dependencies = dependencies;
    }

    /**
     * Converts the WorkReport to a plain object for serialization (excluding signature for hashing).
     * @returns {object}
     */
    toSignableObject() {
        return {
            workPackage: this.workPackage.toObject(),
            refinementContext: this.refinementContext.toObject(),
            pvmOutput: this.pvmOutput,
            gasUsed: this.gasUsed,
            availabilitySpec: this.availabilitySpec ? this.availabilitySpec.toObject() : null,
            coreIndex: this.coreIndex,
            slot: this.slot,
            dependencies: this.dependencies,
        };
    }

    /**
     * Converts the WorkReport to a plain object for full serialization (including signature).
     * @returns {object}
     */
    toObject() {
        return {
            ...this.toSignableObject(),
            guarantorSignature: this.guarantorSignature,
            guarantorPublicKey: this.guarantorPublicKey,
        };
    }
}